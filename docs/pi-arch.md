# 理解 `pi-ai`：一份不看代码的架构导读

这份文档只回答四件事：

1. 它要做什么（设计理念）
2. 它有哪些核心抽象，以及抽象之间如何协作
3. 它对外暴露什么接口
4. 它的核心数据模型是什么

不展开具体类或源码细节。

---

## 1. 设计理念：它要做什么

`pi-ai` 的目标不是“再提供一个聊天 SDK”，而是提供一个 **面向 Agent 工作流的模型协议层**。

它解决的问题是：

- 不同模型厂商的协议差异很大（消息格式、工具调用格式、流式事件、停止原因、计费字段都不一样）
- 但 Agent 运行时希望看到的是一套稳定语义（谁发言、是否调工具、工具参数、结果回灌、何时结束）

所以它的核心价值是：  
**把“多厂商模型差异”收敛成“统一 Agent 语义”。**

你可以把它理解成：  
“上面是你的 Agent 逻辑，下面是模型厂商 API，`pi-ai` 是中间的协议适配层”。

> 补充：这不代表它发明了新的交互范式。  
> Codex / Claude Code 这类现成产品内部也有类似机制。区别在于：`pi-ai` 把这套机制开放成可编排的库，供你自己掌控。

---

## 2. 核心抽象与关系

下面是最重要的抽象关系（从上到下）：

### A. Model（模型能力描述）

它描述“要调用谁”以及“这个模型有什么能力”：

- 来自哪个 provider
- 走哪类 API 协议
- 支持哪些输入（文本、图片）
- 是否支持 reasoning/thinking
- 上下文窗口、token 上限、价格信息

作用：为后续调用选择正确的协议路径和能力边界。

### B. Context（一次请求的上下文）

它描述“这次调用给模型什么信息”：

- 系统指令
- 历史消息
- 可用工具定义

作用：作为一次模型调用的完整输入。

### C. Message（对话与工具结果）

统一成三类消息：

- 用户消息
- 助手消息（可包含文本、thinking、tool call）
- 工具结果消息（tool result）

作用：让“聊天内容”和“工具执行结果”处于同一条会话链里。

### D. Event Stream（增量输出协议）

模型输出不是只给一段最终文本，而是持续发事件：

- 文本增量
- thinking 增量
- tool call 参数增量
- 完成/错误

作用：让上层能实时渲染、实时决策、实时审计，而不是等整段文本结束再猜意图。

### E. Provider Adapter（厂商适配器）

每个厂商协议都由适配器负责：

1. 把统一 `Context/Message` 转成厂商请求格式  
2. 把厂商流式响应转回统一事件  
3. 处理兼容问题（ID、签名、停止原因、计费字段等）

作用：把不稳定的外部协议隔离在边界内。

当 provider 能力不完整时，Adapter 还负责“降级或拒绝”策略：

1. 不支持 Tool Calling
- 若当前调用依赖工具：可选择报错（显式失败）或不将该模型纳入可用 Agent 模型。
- 若允许降级：以“无工具模式”调用（`tools=[]`），只保留文本对话语义。

2. 不支持流式增量事件
- Adapter 仍向上层输出统一事件接口，但事件来源改为“包装的一次性结果”。
- 常见做法是合成：`message_start -> message_update(完整文本) -> message_end`。
- 对上层 runtime 来说，消费接口不变，只是实时性变弱。

### F. Unified Facade（统一调用入口）

上层 Agent 不关心厂商细节，只通过统一入口发起：

- 流式调用
- 非流式调用
- 简化调用（统一 reasoning 级别）

作用：让业务逻辑与厂商协议解耦。

### G. 你最关心的三层心智模型（Action / Behavior / Scenario）

这一层不是额外代码类型，而是对已有抽象的组织方式：

1. `Action`（原子动作）= `Tool`
- 最小可执行能力单元，例如 `read_file`、`create_mr`、`notify_slack`。
- 在 `pi` 体系里，Tool 是模型可直接调用的原子接口。

2. `Behavior`（行为）= 一段可复用编排逻辑
- 用一组 Action 完成“可复用的小目标”，例如“读取 ticket 并提取实施要点”。
- 在实践里可落在：`Skill`、`/command`、或 `Extension` 的事件处理逻辑中。

3. `Scenario`（调度场景）= 跨回合、跨行为的业务工作流
- 把多个 Behavior 组合成完整流程，例如：读 Jira -> 读 MR 评论 -> 改代码 -> 更新 MR -> Slack 通知。
- 典型由 `Extension + 事件流 + 会话状态`驱动，而不是单条提示词硬编码。

这三层关系是：
`Tool (Action)` < `Behavior (编排片段)` < `Scenario (业务流程)`

框架并不强制你使用固定 DSL，而是提供事件驱动运行时，你在其上实现自己的状态机与策略。

---

## 3. 抽象之间如何通信（关键信息流）

你可以把一次调用看成 5 段信息流：

1. **能力选择流**：`Model`  
决定走哪个 provider/API、有哪些能力边界。

2. **输入上下文流**：`Context`  
把系统提示、消息历史、可用工具一起交给模型。

3. **增量输出流**：`Event Stream`  
模型持续发 `text/thinking/toolcall` 的增量事件。

4. **执行回灌流**：`Tool Result Message`  
外部程序执行工具后，把结果作为标准消息回灌给模型。

5. **终止与统计流**：`StopReason + Usage`  
告诉上层这轮为什么结束、用了多少 token、花费如何。

这 5 段流拼起来，就是一个完整 Agent 回合：

`选择模型 -> 提供上下文 -> 接收事件 -> 执行工具并回灌 -> 结束并统计`

---

## 4. 对外接口（从使用者视角）

从抽象层看，对外接口分四组：

### 4.1 统一推理接口

- 流式调用（消费增量事件）
- 一次性调用（直接拿最终消息）
- 简化调用（用统一 reasoning 等级，而不是各厂商参数）

### 4.2 模型发现接口

- 列出可用 provider
- 列出 provider 下的模型
- 获取特定模型描述

### 4.3 认证接口

- 从运行环境解析 provider 凭据
- 支持 OAuth provider 的登录、刷新和取 token

### 4.4 工具参数校验接口

- 对模型生成的 tool call 参数做 schema 校验
- 在执行前把“不合法参数”挡住

### 4.5 除了 Tool，你还能扩展什么

如果你直接把它当 Agent 产品使用（`pi-coding-agent`），可扩展面不止 Tool：

1. `Extension`
- 注册 Tool、命令、快捷键、事件处理器、消息渲染器。
- 可维护会话级状态，形成 Behavior/Scenario 编排。

2. `Skill`
- Markdown 形态的可复用能力包，适合流程提示与规范注入。

3. `Prompt Template`
- 参数化模板，作为固定任务入口。

4. `UI 扩展`
- Widget、Header/Footer、自定义编辑器、Overlay。

5. `策略控制`
- 动态启用/禁用工具、切换模型/thinking level、在事件中拦截和改写行为。

---

## 5. 核心数据模型（语义层）

从“语义”而非代码定义看，最核心的是四个对象：

### 5.1 `Model`

语义：**能力声明 + 路由声明 + 成本声明**

### 5.2 `Context`

语义：**一次调用的完整输入包**

### 5.3 `Message`

语义：**会话状态的最小记账单位**  
既记录自然语言，也记录工具调用和工具结果。

### 5.4 `AssistantMessageEvent`

语义：**运行期增量状态变化**  
不是存档消息，而是“进行中的动作事件”。

---

## 6. 事件流 vs 文本流（为什么要事件优先）

很多系统只提供“文本流”：不断给你字符串。  
`pi-ai` 提供的是“事件流”：每个增量都有类型。

### 文本流

- 你看到的是一段不断增长的文本
- 你很难可靠判断“现在是在思考、在输出答案、还是在拼工具参数”

### 事件流

- 你明确知道当前增量属于哪个通道：text/thinking/toolcall
- 你可以只在“工具调用完成事件”后执行工具
- 你可以把 thinking 与答案分开显示
- 你可以对不同事件做不同审计和重试策略

补充：并非所有 provider 都原生支持完整增量事件。  
`pi-ai` 的做法是“上层统一事件语义，下层按能力适配”：

1. 原生支持流式的 provider  
- 直接映射为增量事件。

2. 仅支持一次性返回的 provider  
- 由 Adapter 封装成伪流式事件序列（通常是 start/update/end 三段）。

3. 因此上层代码不需要分叉  
- 仍然按统一事件流编排；差异被收敛在 Adapter 层。

一句话：  
**文本流适合展示，事件流适合构建可控系统。**

---

## 7. 给你的实践结论

如果你只想“让模型更好用”，现成产品（Codex/Claude Code）通常够了。  
如果你要“构建自己的 Agent 系统能力”，`pi-ai` 的价值在于：

- 给你统一协议层
- 给你可控事件流
- 给你跨厂商兼容语义
- 让上层 runtime/策略/审计可以稳定落地

它不是替代 Agent runtime，而是让 runtime 可以稳定地“跨模型工作”。

---

## 8. 与 Codex / Claude Code 的术语对照（按你要的心智模型）

这里把 `Cloud Code` 按 `Claude Code` 理解，按你关心的三层来对照：

### 8.1 Tool / Behavior / Scenario 对照表

| 你的心智层级 | `pi`（本仓库） | Codex | Claude Code（Cloud Code） | 说明 |
|---|---|---|---|---|
| `Tool`（原子 Action） | `Tool` | `Tool` / `function`（API 语义） | `Tool`（内置）+ `MCP tool` | 三者都有明确对应 |
| `Behavior`（一组 Action 形成的小行为） | 常见落点：`Skill` / `/command` / `Extension` 逻辑 | 没有单一官方名词，通常体现在提示模板、命令习惯、外部封装逻辑 | 常见落点：`/command` + `Skill` + MCP 组合 | 三者都能做，但命名与承载形态不同 |
| `Scenario`（跨回合业务编排） | 常见落点：`Extension` 事件驱动状态机（会话级） | 常见落点：外部 orchestrator 或你自己的应用层工作流 | 常见落点：外部 orchestrator，或基于命令/MCP 的流程组合 | 都能实现，但 `pi` 对“自定义编排层”最直接 |

### 8.2 你可以怎样理解“有没有对应实现”

1. `Tool` 层：三者都有，几乎一一对应。  
2. `Behavior` 层：都有，但 Codex/Claude Code 更偏“产品能力组合”，`pi` 更偏“你自己定义结构”。  
3. `Scenario` 层：都能做，差异在于你是否能直接掌控运行时编排（事件、状态、策略、UI）。
